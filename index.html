<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Webcam‑Driven Fluid Simulation</title>
  <style>
    :root{ --bg:#0b0f19; --panel:#121829; --fg:#e6eaf3; --muted:#93a0b8; --accent:#7aa2ff; --danger:#ef4444; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 600px at 70% -10%,#17203a 0%,#0b0f19 40%,#070a12 100%);color:var(--fg);font:14px/1.4 system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100vh}
    header{display:flex;gap:.75rem;align-items:center;justify-content:space-between;padding:.9rem 1rem;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,0));backdrop-filter:blur(6px);border-bottom:1px solid rgba(255,255,255,.07)}
    header .title{display:flex;gap:.75rem;align-items:center}
    .dot{width:10px;height:10px;border-radius:50%;background:linear-gradient(135deg,var(--accent),#9ae6ff);box-shadow:0 0 0 3px rgba(122,162,255,.15),0 0 18px var(--accent)}
    h1{font-size:16px;margin:0;font-weight:600;letter-spacing:.2px;color:#eaf1ff}
    main{display:grid;grid-template-columns:1fr 400px;gap:12px;padding:12px}
    body.controls-hidden main{grid-template-columns:1fr}
    .panel{background:rgba(6,10,20,.55);border:1px solid rgba(255,255,255,.08);border-radius:16px;box-shadow:0 10px 35px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.05)}
    #stage{position:relative;display:grid;place-items:center;overflow:hidden}
    canvas#sim{width:100%;height:100%;display:block;border-radius:16px}
    .hud{position:absolute;inset:auto 10px 10px auto;display:flex;gap:8px;align-items:center}
    .chip{display:inline-flex;align-items:center;gap:6px;background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.1);padding:.4rem .55rem;border-radius:999px;color:#dbe5ff}
    .chip small{opacity:.8}
    .chip.btn{cursor:pointer;user-select:none}
    .controls{padding:12px 14px;display:flex;flex-direction:column;gap:10px}
    body.controls-hidden aside.controls{display:none}
    .section{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.07);border-radius:14px;padding:10px}
    .row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:8px;padding:6px 4px}
    .row label{color:#cdd7f6;font-size:12px}
    .row input[type="range"]{width:180px}
    .btns-4{display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:8px;margin-top:4px}
    button{padding:.6rem .8rem;border-radius:12px;border:1px solid rgba(255,255,255,.08);background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));color:#eaf1ff;cursor:pointer;transition:.2s transform,.2s background}
    button:hover{transform:translateY(-1px);background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.04))}
    button:disabled{opacity:.5;cursor:not-allowed}
    .accent{border-color:rgba(122,162,255,.4);box-shadow:0 8px 30px rgba(122,162,255,.15) inset}
    .danger{border-color:rgba(239,68,68,.35)}
    .notice{padding:.65rem .8rem;margin:.4rem 0;border-radius:12px;background:rgba(34,197,94,.08);border:1px solid rgba(34,197,94,.28);color:#c5f8d2}
    footer{display:flex;align-items:center;justify-content:space-between;gap:10px;padding:10px 14px;color:var(--muted)}
    .legend{display:flex;gap:14px;align-items:center;flex-wrap:wrap}
    .legend > div{display:flex;gap:6px;align-items:center}
    .key{width:10px;height:10px;border-radius:3px;background:linear-gradient(135deg,#6ee7b7,#93c5fd)}
    video,canvas.off{display:none}
    @media (max-width: 980px){ main{grid-template-columns:1fr;grid-template-rows:auto auto} }
    .color-rows{display:grid;grid-template-columns:1fr auto;gap:8px}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="title"><div class="dot"></div><h1>Webcam‑Driven Fluid Simulation</h1></div>
    <div class="legend"><div><span class="key"></span> motion → velocity & dye</div></div>
  </header>

  <main>
    <section id="stage" class="panel" aria-live="polite">
      <canvas id="sim" width="960" height="540" aria-label="Fluid simulation canvas"></canvas>
      <div class="hud">
        <div class="chip"><small>Cam:</small> <span id="camState">starting…</span></div>
        <div class="chip"><small>fps</small> <span id="fps">–</span></div>
        <button id="toggleControls" class="chip btn" title="Hide/Show controls">🗂 Hide UI</button>
        <button id="fullscreenBtn" class="chip btn" title="Toggle fullscreen">⛶ Fullscreen</button>
      </div>
      <video id="cam" playsinline muted></video>
      <canvas id="camWork" class="off"></canvas>
      <canvas id="camPrev" class="off"></canvas>
      <canvas id="camBase" class="off"></canvas>
    </section>

    <aside class="panel controls" id="controls">
      <div class="section">
        <div class="row"><label>Simulation Resolution</label><input id="res" type="range" min="64" max="192" value="128" step="16"><span id="resV">128</span></div>
        <div class="row"><label>Viscosity</label><input id="visc" type="range" min="0" max="0.01" value="0.0008" step="0.0002"><span id="viscV">0.0008</span></div>
        <div class="row"><label>Diffusion</label><input id="diff" type="range" min="0" max="0.003" value="0.0006" step="0.0001"><span id="diffV">0.0006</span></div>
        <div class="row"><label>Time step</label><input id="dt" type="range" min="0.005" max="0.033" value="0.030" step="0.001"><span id="dtV">0.016</span></div>
      </div>
      <div class="section">
        <div class="row"><label>Motion threshold</label><input id="thr" type="range" min="5" max="80" value="18" step="1"><span id="thrV">18</span></div>
        <div class="row"><label>Flow strength</label><input id="flow" type="range" min="10" max="180" value="90" step="5"><span id="flowV">90</span></div>
        <div class="row"><label>Ink intensity</label><input id="ink" type="range" min="5" max="300" value="160" step="5"><span id="inkV">160</span></div>
        <div class="row"><label>Fade time (s)</label><input id="fade" type="range" min="0.5" max="5" value="0.5" step="0.1"><span id="fadeV">2</span></div>
        <div class="row"><label>Show motion preview</label><input id="showMotion" type="checkbox" checked><span></span></div>
        <div class="btns-4">
          <button id="toggle" class="accent" aria-pressed="true">⏸ Pause</button>
          <button id="resetBg" class="danger" title="Reset motion baseline in 3 seconds">🔄 Reset background</button>
          <button id="startCam">📷 Start camera</button>
          <button id="toggleMirror">🪞 Mirror: Off</button>
        </div>
        <div id="msg" class="notice" style="display:none"></div>
      </div>
      <div class="section">
        <div class="row"><label>Pointer draws ink</label><input id="pointerInk" type="checkbox"><span></span></div>
        <div class="row"><label>Color mode</label>
          <select id="colorMode">
            <option value="custom1" selected>Custom (single)</option>
            <option value="custom2">Custom (dual cycle)</option>
            <option value="sample">Sample from video</option>
            <option value="rainbow">Rainbow</option>
          </select>
          <span></span>
        </div>
        <div class="row color-rows"><label>Color 1</label><input id="color1" type="color" value="#66aaff" /></div>
        <div class="row color-rows"><label>Color 2</label><input id="color2" type="color" value="#ff66aa" /></div>
      </div>
      <small style="opacity:.7">Tip: strong motions create stronger currents. Click “Reset background” if lighting or the scene changed. Use “Start camera” if the feed stalls. Use “Mirror” to flip the camera horizontally.</small>
    </aside>
  </main>

  <footer>
    <div>Built with <strong>Stable Fluids</strong> (CPU) + webcam motion → forces & dye.</div>
    <div id="status"></div>
  </footer>
</div>

<script>
(() => {
  // ----- Utilities
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const now=()=>performance.now();
  const hexToRGB=(hex)=>{ let s=(hex||"#66aaff").toString().trim(); if(s[0]==="#") s=s.slice(1); if(s.length===3) s=s.split("").map(c=>c+c).join(""); const r=parseInt(s.slice(0,2),16)/255, g=parseInt(s.slice(2,4),16)/255, b=parseInt(s.slice(4,6),16)/255; return {r:(r||0),g:(g||0),b:(b||0)}; };

  // ----- DOM
  const simCanvas = document.getElementById('sim');
  const ctx = simCanvas.getContext('2d', { alpha: false });
  const vid = document.getElementById('cam');
  const camState = document.getElementById('camState');
  const fpsEl = document.getElementById('fps');
  const msg = document.getElementById('msg');
  const status = document.getElementById('status');
  const stageEl = document.getElementById('stage');

  // HUD buttons
  const toggleControlsBtn = document.getElementById('toggleControls');
  const fullscreenBtn = document.getElementById('fullscreenBtn');

  // Controls
  const $ = id => document.getElementById(id);
  const controls = {
    res: $('res'), resV: $('resV'),
    visc: $('visc'), viscV: $('viscV'),
    diff: $('diff'), diffV: $('diffV'),
    dt: $('dt'), dtV: $('dtV'),
    thr: $('thr'), thrV: $('thrV'),
    flow: $('flow'), flowV: $('flowV'),
    ink: $('ink'), inkV: $('inkV'),
    fade: $('fade'), fadeV: $('fadeV'),
    showMotion: $('showMotion'),
    toggle: $('toggle'),
    resetBg: $('resetBg'),
    startCam: $('startCam'),
    toggleMirror: $('toggleMirror'),
    pointerInk: $('pointerInk'),
    colorMode: $('colorMode'),
    color1: $('color1'),
    color2: $('color2')
  };

  // Update numeric displays
  for (const k of ['res','visc','diff','dt','thr','flow','ink','fade']){
    const el = controls[k], out = controls[k+'V'];
    const fmt = (v)=>({visc:(+v).toFixed(4),diff:(+v).toFixed(4),dt:(+v).toFixed(3),fade:(+v).toFixed(1)}[k]||v);
    const upd=()=>{ if(out) out.textContent = fmt(el.value); };
    el.addEventListener('input',()=>{ upd(); if(k==='res') resizeSimulation(+el.value); });
    upd();
  }

  // ----- Camera setup (robust)
  const camW = 320, camH = 240, TILE = 8, SEARCH_R = 2;
  const camWork = document.getElementById('camWork');
  const camPrev = document.getElementById('camPrev');
  const camBase = document.getElementById('camBase');
  Object.assign(camWork,{width:camW,height:camH});
  Object.assign(camPrev,{width:camW,height:camH});
  Object.assign(camBase,{width:camW,height:camH});
  const camCtx = camWork.getContext('2d');
  const prevCtx = camPrev.getContext('2d');
  const baseCtx = camBase.getContext('2d');

  let haveBase=false, baseImg=null, stream=null, mirror=true;

  function drawCamTo(targetCtx){
    if(!vid) return;
    if(mirror){ targetCtx.save(); targetCtx.translate(camW,0); targetCtx.scale(-1,1); targetCtx.drawImage(vid,0,0,camW,camH); targetCtx.restore(); }
    else { targetCtx.drawImage(vid,0,0,camW,camH); }
  }

  async function stopCamera(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } }

  function waitForVideoVideoWidth(vid, timeout=2500){
    return new Promise((resolve, reject)=>{
      if(vid.readyState>=2 && vid.videoWidth){ return resolve(); }
      const to = setTimeout(()=>reject(new Error('timeout waiting for frames')), timeout);
      const onReady=()=>{ if(vid.videoWidth){ clearTimeout(to); cleanup(); resolve(); } };
      function cleanup(){ vid.removeEventListener('loadedmetadata', onReady); vid.removeEventListener('playing', onReady); }
      vid.addEventListener('loadedmetadata', onReady); vid.addEventListener('playing', onReady);
    });
  }

  async function getStreamWithFallbacks(){
    const trials = [
      { video: { width:{ideal:1280}, height:{ideal:720}, frameRate:{ideal:30}, facingMode:'user' }, audio:false },
      { video: { width:640, height:480 }, audio:false },
      { video: true, audio:false }
    ];
    let lastErr;
    for(const c of trials){ try { return await navigator.mediaDevices.getUserMedia(c); } catch(e){ lastErr=e; } }
    throw lastErr || new Error('getUserMedia failed');
  }

  async function initCamera(){
    try{
      camState.textContent = 'starting…'; camState.style.color = '#fde68a';
      await stopCamera();
      stream = await getStreamWithFallbacks();
      vid.srcObject = stream; await vid.play().catch(()=>{}); await waitForVideoVideoWidth(vid, 3500);
      camState.textContent = 'on'; camState.style.color = '#86efac';
      setTimeout(()=>{ drawCamTo(baseCtx); baseImg = baseCtx.getImageData(0,0,camW,camH); haveBase=true; }, 400);
      stream.getVideoTracks().forEach(tr=>{
        tr.addEventListener('ended', ()=>{ camState.textContent='ended'; camState.style.color='#fca5a5'; });
        tr.addEventListener('mute', ()=>{ camState.textContent='muted'; camState.style.color='#fca5a5'; });
        tr.addEventListener('unmute', ()=>{ camState.textContent='on'; camState.style.color='#86efac'; });
      });
    }catch(err){ console.error('Camera error', err); camState.textContent = 'blocked'; camState.style.color = '#fca5a5'; showMsg('Camera failed to start. Try clicking “Start camera”.', 'warn', 5000); }
  }

  controls.startCam.addEventListener('click', ()=>{ initCamera(); });
  controls.toggleMirror.addEventListener('click', ()=>{ mirror=!mirror; controls.toggleMirror.textContent = mirror ? '🪞 Mirror: On' : '🪞 Mirror: Off'; showMsg(mirror? 'Camera mirrored' : 'Camera normal'); if(haveBase){ drawCamTo(baseCtx); baseImg = baseCtx.getImageData(0,0,camW,camH); } });

  function showMsg(t, kind='ok', timeout=2400){
    msg.textContent = t; msg.style.display='block';
    msg.style.background = kind==='ok'? 'rgba(34,197,94,.08)' : kind==='warn' ? 'rgba(245,158,11,.09)' : 'rgba(239,68,68,.10)';
    msg.style.borderColor = kind==='ok'? 'rgba(34,197,94,.28)' : kind==='warn' ? 'rgba(245,158,11,.3)' : 'rgba(239,68,68,.35)';
    clearTimeout(showMsg._t); showMsg._t = setTimeout(()=> msg.style.display='none', timeout);
  }

  // ----- Fluid (Stable Fluids, CPU)
  let NX=128, NY=Math.round(NX*(simCanvas.height/simCanvas.width));
  let iterP = 16, iterD = 8;
  let dt = +controls.dt.value; let diff = +controls.diff.value; let visc = +controls.visc.value;
  function idx(x,y){ return x + (NX+2)*y; }
  function makeField(){ return new Float32Array((NX+2)*(NY+2)); }
  let u,v,u0,v0, r,g,b, r0,g0,b0, p, div;
  function alloc(){ u=makeField(); v=makeField(); u0=makeField(); v0=makeField(); r=makeField(); g=makeField(); b=makeField(); r0=makeField(); g0=makeField(); b0=makeField(); p=makeField(); div=makeField(); }
  function set_bnd(b, x){ for(let i=1;i<=NX;i++){ x[idx(i,0)]   = b===2? -x[idx(i,1)] : x[idx(i,1)]; x[idx(i,NY+1)]= b===2? -x[idx(i,NY)] : x[idx(i,NY)]; } for(let j=1;j<=NY;j++){ x[idx(0,j)]   = b===1? -x[idx(1,j)] : x[idx(1,j)]; x[idx(NX+1,j)]= b===1? -x[idx(NX,j)] : x[idx(NX,j)]; } x[idx(0,0)]           = 0.5*(x[idx(1,0)]     + x[idx(0,1)]); x[idx(0,NY+1)]        = 0.5*(x[idx(1,NY+1)]  + x[idx(0,NY)]); x[idx(NX+1,0)]        = 0.5*(x[idx(NX,0)]    + x[idx(NX+1,1)]); x[idx(NX+1,NY+1)]     = 0.5*(x[idx(NX,NY+1)] + x[idx(NX+1,NY)]); }
  function lin_solve(b, x, x0, a, c, iters){ const cRecip = 1.0/c; for(let k=0;k<iters;k++){ for(let j=1;j<=NY;j++){ for(let i=1;i<=NX;i++){ x[idx(i,j)] = (x0[idx(i,j)] + a*(x[idx(i-1,j)] + x[idx(i+1,j)] + x[idx(i,j-1)] + x[idx(i,j+1)])) * cRecip; } } set_bnd(b,x); } }
  function diffuse(b, x, x0, diff, dt, iters){ const a = dt*diff*NX*NY; lin_solve(b,x,x0,a,1+4*a,iters); }
  function advect(b, d, d0, u, v, dt){ const dt0x = dt*NX, dt0y = dt*NY; for(let j=1;j<=NY;j++){ for(let i=1;i<=NX;i++){ let x = i - dt0x * u[idx(i,j)]; let y = j - dt0y * v[idx(i,j)]; if(x<0.5) x=0.5; if(x>NX+0.5) x=NX+0.5; if(y<0.5) y=0.5; if(y>NY+0.5) y=NY+0.5; const i0 = Math.floor(x), i1 = i0+1; const j0 = Math.floor(y), j1 = j0+1; const s1 = x - i0, s0 = 1 - s1; const t1 = y - j0, t0 = 1 - t1; d[idx(i,j)] = s0*(t0*d0[idx(i0,j0)] + t1*d0[idx(i0,j1)]) + s1*(t0*d0[idx(i1,j0)] + t1*d0[idx(i1,j1)]); } } set_bnd(b,d); }
  function project(u,v,p,div){ const h = 1.0/Math.max(NX,NY); for(let j=1;j<=NY;j++){ for(let i=1;i<=NX;i++){ div[idx(i,j)] = -0.5*h*( u[idx(i+1,j)] - u[idx(i-1,j)] + v[idx(i,j+1)] - v[idx(i,j-1)] ); p[idx(i,j)] = 0; } } set_bnd(0,div); set_bnd(0,p); lin_solve(0,p,div,1,4,iterP); for(let j=1;j<=NY;j++){ for(let i=1;i<=NX;i++){ u[idx(i,j)] -= 0.5*(p[idx(i+1,j)] - p[idx(i-1,j)]) / h; v[idx(i,j)] -= 0.5*(p[idx(i,j+1)] - p[idx(i,j-1)]) / h; } } set_bnd(1,u); set_bnd(2,v); }
  function vel_step(u,v,u0,v0,visc,dt){ for(let k=0;k<u.length;k++){ u[k]+=dt*u0[k]; v[k]+=dt*v0[k]; u0[k]=0; v0[k]=0; } diffuse(1,u0,u,visc,dt,iterD); diffuse(2,v0,v,visc,dt,iterD); project(u0,v0,p,div); advect(1,u,u0,u0,v0,dt); advect(2,v,v0,u0,v0,dt); project(u,v,p,div); }
  function dens_step(d,d0,u,v,diff,dt){ for(let k=0;k<d.length;k++){ d[k]+=dt*d0[k]; d0[k]=0; } diffuse(0,d0,d,diff,dt,iterD); advect(0,d,d0,u,v,dt); }
  function resizeSimulation(nx){ NX = nx|0; NY = Math.max(32, Math.round(NX*(simCanvas.height/simCanvas.width))); alloc(); }
  alloc();
  let lastActive = 0;

  // ----- Rendering
  let img = ctx.createImageData(simCanvas.width, simCanvas.height);
  function render(){ const W = simCanvas.width, H = simCanvas.height; const sx = NX/(W), sy = NY/(H); const data = img.data; let p = 0; for(let y=0;y<H;y++){ const gy = 1 + (y+0.5)*sy; const j0 = Math.floor(gy), j1 = Math.min(NY, j0+1), ty = gy - j0, tty = 1-ty; for(let x=0;x<W;x++){ const gx = 1 + (x+0.5)*sx; const i0 = Math.floor(gx), i1 = Math.min(NX, i0+1), tx = gx - i0, ttx = 1-tx; const i00 = idx(i0,j0), i01 = idx(i0,j1), i10 = idx(i1,j0), i11 = idx(i1,j1); const rr = ttx*(tty*r[i00] + ty*r[i01]) + tx*(tty*r[i10] + ty*r[i11]); const gg = ttx*(tty*g[i00] + ty*g[i01]) + tx*(tty*g[i10] + ty*g[i11]); const bb = ttx*(tty*b[i00] + ty*b[i01]) + tx*(tty*b[i10] + ty*b[i11]); data[p++] = (Math.max(0,Math.min(255,rr*255))|0); data[p++] = (Math.max(0,Math.min(255,gg*255))|0); data[p++] = (Math.max(0,Math.min(255,bb*255))|0); data[p++] = 255; } } ctx.putImageData(img,0,0); }

  // ----- Motion → Forces & Ink
  let rainbowHue = 0; let cyclePhase = 0;
  function motionToFluid(){
    if(!vid.videoWidth) return 0;
    drawCamTo(camCtx);
    const cur = camCtx.getImageData(0,0,camW,camH);
    if(!motionToFluid.prev){ drawCamTo(prevCtx); motionToFluid.prev = prevCtx.getImageData(0,0,camW,camH); }
    const prev = motionToFluid.prev;

    let activeCount = 0;
    if(haveBase && baseImg){
      const thr = +controls.thr.value; const thrPrev = thr*0.6; const flowStrength = +controls.flow.value / 60; const inkBase = +controls.ink.value / 255;
      for(let ty=0; ty<camH; ty+=TILE){
        for(let tx=0; tx<camW; tx+=TILE){
          let sumB=0,sumP=0,n=0;
          for(let y=0;y<TILE;y++){
            const py=ty+y; if(py>=camH) continue; const off=(py*camW+tx)*4;
            for(let x=0;x<TILE;x++){
              const px=tx+x; if(px>=camW) continue; const i=off+x*4;
              const r=cur.data[i], g=cur.data[i+1], b=cur.data[i+2];
              const rb=baseImg.data[i], gb=baseImg.data[i+1], bb=baseImg.data[i+2];
              const rp=prev.data[i], gp=prev.data[i+1], bp=prev.data[i+2];
              sumB += Math.abs((r+g+b)-(rb+gb+bb))/3; sumP += Math.abs((r+g+b)-(rp+gp+bp))/3; n++;
            }
          }
          const avgB=sumB/(n||1), avgP=sumP/(n||1);
          if(avgB>thr || avgP>thrPrev){
            activeCount++;
            // Block match against prev to get direction
            let bestDX=0,bestDY=0,bestSAD=1e12;
            for(let dy=-SEARCH_R; dy<=SEARCH_R; dy++){
              for(let dx=-SEARCH_R; dx<=SEARCH_R; dx++){
                let sad=0,m=0;
                for(let y=0;y<TILE;y++){
                  const py=ty+y, py2=Math.max(0,Math.min(camH-1,py+dy));
                  for(let x=0;x<TILE;x++){
                    const px=tx+x, px2=Math.max(0,Math.min(camW-1,px+dx));
                    const i1=(py*camW+px)*4, i0=(py2*camW+px2)*4;
                    const dr=cur.data[i1]-prev.data[i0]; const dg=cur.data[i1+1]-prev.data[i0+1]; const db=cur.data[i1+2]-prev.data[i0+2];
                    sad += Math.abs(dr)+Math.abs(dg)+Math.abs(db); m++;
                  }
                }
                if(sad<bestSAD){ bestSAD=sad; bestDX=dx; bestDY=dy; }
              }
            }
            const cx=tx+TILE*0.5, cy=ty+TILE*0.5; const si=1+Math.floor(cx/camW*NX); const sj=1+Math.floor(cy/camH*NY);
            // distribute into 3x3 around center for smoother look
            const c1=hexToRGB(controls.color1.value), c2=hexToRGB(controls.color2.value); const mode=controls.colorMode.value;
            let cr=0.6,cg=0.75,cb=1.0; if(mode==='rainbow'){ rainbowHue=(rainbowHue+180*dt)%360; const h=rainbowHue,s=0.9,v=1.0; const c=v*s,x=c*(1-Math.abs((h/60)%2-1)),m=v-c; let R=0,G=0,B=0; if(h<60){R=c;G=x;B=0}else if(h<120){R=x;G=c;B=0}else if(h<180){R=0;G=c;B=x}else if(h<240){R=0;G=x;B=c}else if(h<300){R=x;G=0;B=c}else{R=c;G=0;B=x} cr=R+m; cg=G+m; cb=B+m; } else if(mode==='sample'){ let sr=0,sg=0,sb=0,m=0; for(let y=0;y<TILE;y++){ for(let x=0;x<TILE;x++){ const i=((ty+y)*camW+(tx+x))*4; sr+=cur.data[i]; sg+=cur.data[i+1]; sb+=cur.data[i+2]; m++; } } if(m){ cr=sr/(255*m); cg=sg/(255*m); cb=sb/(255*m); } } else { const t=(mode==='custom2')? (cyclePhase%1):0; cr=(1-t)*c1.r+t*c2.r; cg=(1-t)*c1.g+t*c2.g; cb=(1-t)*c1.b+t*c2.b; }
            const mag=Math.max(0,Math.min(2,(avgP+avgB*0.5)/128)); const vv=(+controls.flow.value/60)*mag; const addBase=(+controls.ink.value/255)*mag;
            for(let oy=-1; oy<=1; oy++){
              for(let ox=-1; ox<=1; ox++){
                const ii=Math.max(1,Math.min(NX,si+ox)), jj=Math.max(1,Math.min(NY,sj+oy)), cid=idx(ii,jj);
                const w=(ox===0 && oy===0)?1.0:0.6;
                const rate = 1/Math.max(1e-4, dt); // make injection time-step independent
                u0[cid]+=vv*bestDX*w*rate; v0[cid]+=vv*bestDY*w*rate;
                const add=addBase*w*rate; r0[cid]+=add*cr; g0[cid]+=add*cg; b0[cid]+=add*cb;
              }
            }
          }
        }
      }
    }
    prevCtx.putImageData(cur,0,0); motionToFluid.prev = prevCtx.getImageData(0,0,camW,camH);
    if(controls.colorMode.value==='custom2') cyclePhase=(cyclePhase+dt*0.4)%1;
    return activeCount;
  }

  // ----- Pointer input (optional drawing)
  let pointerDown=false, lastPX=0, lastPY=0;
  simCanvas.addEventListener('pointerdown', e=>{ pointerDown=true; const r=simCanvas.getBoundingClientRect(); lastPX=(e.clientX-r.left)/r.width; lastPY=(e.clientY-r.top)/r.height; });
  window.addEventListener('pointerup', ()=> pointerDown=false);
  simCanvas.addEventListener('pointermove', e=>{
    if(!pointerDown || !controls.pointerInk.checked) return;
    const rct = simCanvas.getBoundingClientRect();
    const x = (e.clientX - rct.left)/rct.width, y=(e.clientY - rct.top)/rct.height;
    const i = 1 + Math.floor(x*NX), j = 1 + Math.floor(y*NY);
    const id = idx(Math.max(1,Math.min(NX,i)), Math.max(1,Math.min(NY,j)));
    const dx = (x-lastPX)*NX, dy=(y-lastPY)*NY; const str = 3.0;
    u0[id] += str*dx; v0[id] += str*dy;
    const c1=hexToRGB(controls.color1.value); r0[id]+=0.25*c1.r; g0[id]+=0.25*c1.g; b0[id]+=0.25*c1.b;
    lastPX=x; lastPY=y;
  });

  // ----- Main loop
  let running=true, lastT=now(), frame=0, fps=0, fpsT=now();
  function loop(){
    if(running){
      const t=now(); let dtRaw=(t-lastT)/1000; lastT=t; dt=+controls.dt.value; diff=+controls.diff.value; visc=+controls.visc.value;
      lastActive = motionToFluid();
      vel_step(u,v,u0,v0,visc,dt);
      dens_step(r,r0,u,v,diff,dt); dens_step(g,g0,u,v,diff,dt); dens_step(b,b0,u,v,diff,dt);
      const fadeS=Math.max(0.1,+controls.fade.value); const k=Math.exp(-Math.log(100)*dt/fadeS); for(let i=0;i<r.length;i++){ r[i]*=k; g[i]*=k; b[i]*=k; }
      render(); frame++; if(t-fpsT>500){ fps = Math.round(frame*1000/(t-fpsT)); fpsEl.textContent=fps; frame=0; fpsT=t; }
      status.textContent = 'grid ' + NX + '×' + NY + ' | motion tiles ' + (lastActive||0);
    }
    requestAnimationFrame(loop);
  }

  // Controls: pause/resume & reset baseline
  controls.toggle.addEventListener('click', ()=>{ running=!running; controls.toggle.textContent = running? '⏸ Pause' : '▶️ Resume'; controls.toggle.setAttribute('aria-pressed', String(running)); if(running){ lastT=now(); } });
  let resetTimer=null, resetCount=0;
  controls.resetBg.addEventListener('click', ()=>{ if(!vid.videoWidth){ showMsg('Camera not ready yet.', 'warn'); return; } if(resetTimer){ clearInterval(resetTimer); resetTimer=null; } resetCount=3; controls.resetBg.disabled=true; showMsg('Resetting background in '+resetCount+'…', 'warn', 4000); resetTimer=setInterval(()=>{ resetCount--; if(resetCount>0){ showMsg('Resetting background in '+resetCount+'…', 'warn', 4000); } else { clearInterval(resetTimer); resetTimer=null; drawCamTo(baseCtx); baseImg=baseCtx.getImageData(0,0,camW,camH); haveBase=true; controls.resetBg.disabled=false; showMsg('Background reset ✔'); } }, 1000); });

  // Resize handling
  function fitCanvas(){ const rect=simCanvas.getBoundingClientRect(); const dpr=Math.max(1,Math.min(2,window.devicePixelRatio||1)); simCanvas.width=Math.round(rect.width*dpr); simCanvas.height=Math.round(rect.height*dpr); resizeSimulation(+controls.res.value); img = ctx.createImageData(simCanvas.width, simCanvas.height); }
  new ResizeObserver(fitCanvas).observe(simCanvas); fitCanvas();

  // Motion preview overlay
  if(controls.showMotion){ const overlay=document.createElement('canvas'); overlay.width=camW; overlay.height=camH; overlay.className='off'; const octx=overlay.getContext('2d'); const show=()=>{ if(!controls.showMotion.checked){ requestAnimationFrame(show); return; } if(haveBase && baseImg && vid.videoWidth){ drawCamTo(camCtx); const cur=camCtx.getImageData(0,0,camW,camH); const thr=+controls.thr.value; const d=octx.createImageData(camW,camH); for(let i=0;i<d.data.length;i+=4){ const diff=Math.abs((cur.data[i]+cur.data[i+1]+cur.data[i+2]) - (baseImg.data[i]+baseImg.data[i+1]+baseImg.data[i+2]))/3; const v=diff>thr?255:0; d.data[i]=v; d.data[i+1]=v; d.data[i+2]=v; d.data[i+3]=v?180:0; } octx.putImageData(d,0,0); const w=Math.min(220, simCanvas.width*0.25), h=w*camH/camW; ctx.save(); ctx.globalAlpha=0.9; ctx.drawImage(overlay, simCanvas.width-w-10, simCanvas.height-h-10, w, h); ctx.restore(); } requestAnimationFrame(show); }; requestAnimationFrame(show); }

  // HUD buttons behavior
  toggleControlsBtn.addEventListener('click', ()=>{ const hidden = document.body.classList.toggle('controls-hidden'); toggleControlsBtn.textContent = hidden ? '🗂 Show UI' : '🗂 Hide UI'; fitCanvas(); });

  async function toggleFullscreen(){
    try{
      if(!document.fullscreenElement){
        if(stageEl.requestFullscreen){ await stageEl.requestFullscreen({ navigationUI: 'hide' }); }
        else if(document.documentElement.requestFullscreen){ await document.documentElement.requestFullscreen(); }
      } else { await document.exitFullscreen(); }
    } catch(e){ showMsg('Fullscreen not available in this browser/page.', 'warn'); }
  }
  fullscreenBtn.addEventListener('click', toggleFullscreen);
  document.addEventListener('fullscreenchange', ()=>{
    fullscreenBtn.textContent = document.fullscreenElement ? '⤢ Exit FS' : '⛶ Fullscreen';
  });

  // Start
  initCamera(); requestAnimationFrame(loop);
})();
</script>
</body>
</html>
