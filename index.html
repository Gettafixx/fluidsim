<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Webcam-Driven Fluid Simulation (Single File)</title>
<style>
  :root {
    --bg: #0b0e13;
    --panel: rgba(18, 22, 28, 0.75);
    --text: #e8eef5;
    --muted: #9fb0c3;
    --accent: #6ee7ff;
    --accent-2: #8b5cf6;
  }
  html, body {
    margin: 0;
    height: 100%;
    background: radial-gradient(1200px 900px at 70% 30%, #0e131b, #090b10 60%, #06070a);
    color: var(--text);
    font-family: ui-sans-serif, system-ui, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji;
    overflow: hidden;
  }
  #wrap {
    position: relative;
    width: 100vw;
    height: 100vh;
  }
  canvas#fluid {
    position: absolute;
    inset: 0;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated; /* upscale our simulation grid nicely */
    background: transparent;
  }
  /* Control panel */
  .panel {
    position: absolute;
    top: 16px; left: 16px;
    width: min(380px, calc(100vw - 32px));
    backdrop-filter: blur(10px);
    background: var(--panel);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    padding: 14px 14px 8px;
  }
  .panel h1 {
    margin: 0 0 8px;
    font-size: 16px;
    letter-spacing: .3px;
    display: flex; align-items: center; gap: 8px;
  }
  .panel h1 .dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: linear-gradient(45deg, var(--accent), var(--accent-2));
    box-shadow: 0 0 12px var(--accent);
  }
  .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; margin: 8px 0; }
  .row label { font-size: 12px; color: var(--muted); }
  .row .val { font-variant-numeric: tabular-nums; font-size: 12px; color: #cfe6ff; }
  .row input[type="range"] { width: 100%; accent-color: var(--accent); }
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 8px; }
  button, select {
    width: 100%;
    background: linear-gradient(180deg, #1a2230, #111827);
    color: var(--text);
    border: 1px solid rgba(255,255,255,.08);
    padding: 10px 12px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 13px;
  }
  button:hover { border-color: rgba(255,255,255,.16); }
  .tiny {
    font-size: 11px; color: var(--muted); margin-top: 6px; line-height: 1.35;
  }
  /* Bottom-right debug motion canvas */
  #motionDebug {
    position: absolute;
    right: 16px; bottom: 16px;
    width: 160px; height: 160px;
    border-radius: 12px;
    overflow: hidden;
    border: 1px solid rgba(255,255,255,.08);
    box-shadow: 0 14px 30px rgba(0,0,0,.35);
    background: #0a0c12;
    display: none;
  }
  #motionDebug canvas { width: 100%; height: 100%; display: block; }
  .status {
    margin-left: auto;
    color: #c3f0ff;
    font-size: 12px;
  }
  .inline { display: inline-flex; align-items: center; gap: 8px; }
  .inline input[type="checkbox"] { transform: translateY(1px); }
  a.link { color: var(--accent); text-decoration: none; border-bottom: 1px dotted var(--accent); }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="fluid"></canvas>

  <div class="panel">
    <h1>
      <span class="dot"></span>
      Webcam-Driven Fluid
      <span id="status" class="status"></span>
    </h1>

    <div class="row">
      <label for="res">Resolution (grid N)</label>
      <select id="res">
        <option value="96">96</option>
        <option value="128" selected>128</option>
        <option value="160">160</option>
        <option value="192">192</option>
        <option value="224">224</option>
      </select>
    </div>

    <div class="row">
      <label for="visc">Viscosity</label>
      <div class="val" id="viscVal">0.0002</div>
    </div>
    <input type="range" id="visc" min="0" max="0.005" step="0.0001" value="0.0002" />

    <div class="row">
      <label for="diff">Diffusion</label>
      <div class="val" id="diffVal">0.0001</div>
    </div>
    <input type="range" id="diff" min="0" max="0.005" step="0.0001" value="0.0001" />

    <div class="row">
      <label for="force">Force scale</label>
      <div class="val" id="forceVal">25</div>
    </div>
    <input type="range" id="force" min="0" max="80" step="1" value="25" />

    <div class="row">
      <label for="dye">Density scale</label>
      <div class="val" id="dyeVal">0.9</div>
    </div>
    <input type="range" id="dye" min="0" max="3" step="0.05" value="0.9" />

    <div class="row">
      <label for="thresh">Motion threshold</label>
      <div class="val" id="threshVal">18</div>
    </div>
    <input type="range" id="thresh" min="0" max="80" step="1" value="18" />

    <div class="row">
      <label for="blur">Motion blur radius</label>
      <div class="val" id="blurVal">1</div>
    </div>
    <input type="range" id="blur" min="0" max="2" step="1" value="1" />

    <div class="grid2">
      <button id="resetBaseline">Reset Motion Baseline (3s)</button>
      <button id="clearFluid">Clear Fluid</button>
    </div>

    <div class="grid2" style="margin-top:8px;">
      <button id="pause">Pause</button>
      <button id="resume" disabled>Resume</button>
    </div>

    <div class="row inline" style="margin-top:10px;">
      <label for="showMotion" class="inline"><input id="showMotion" type="checkbox" /> Show motion debug</label>
      <span class="tiny">Grant camera permission. If the view feels mirrored, that‚Äôs on purpose (natural webcam feel).</span>
    </div>
    <div class="tiny">Tip: wave your hand or move an object; the moving regions inject dye and push the flow.</div>
  </div>

  <div id="motionDebug"><canvas id="motion"></canvas></div>

  <!-- Hidden video for webcam -->
  <video id="video" autoplay playsinline style="display:none;"></video>
</div>

<script>
(() => {
  // =============== Utility helpers ===============
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
  const lerp = (a,b,t) => a + (b - a) * t;

  // Simple pleasant color mapping from density -> RGB
  function densityToRGB(d) {
    // Map density [0, ~3+] to hue/sat/light
    const x = clamp(d / 2.0, 0, 1);
    // Hue from cyan (190deg) to magenta (300deg)
    const h = 190 + 110 * x;
    const s = 80;
    const l = 50 + 20 * x;
    return hslToRgb(h, s, l);
  }
  function hslToRgb(h, s, l) {
    s/=100; l/=100;
    const k = n => (n + h/30) % 12;
    const a = s * Math.min(l, 1-l);
    const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n), 1)));
    return [f(0)*255, f(8)*255, f(4)*255];
  }

  // =============== Fluid Solver (Stable Fluids) ===============
  class Fluid {
    constructor(N, dt, diff, visc) {
      this.N = N;
      this.dt = dt;
      this.diff = diff;
      this.visc = visc;
      const size = (N+2)*(N+2);
      this.s  = new Float32Array(size);      // temp / source
      this.d  = new Float32Array(size);      // density
      this.d0 = new Float32Array(size);      // prev density

      this.u  = new Float32Array(size);      // velocity x
      this.v  = new Float32Array(size);      // velocity y
      this.u0 = new Float32Array(size);      // prev vel x
      this.v0 = new Float32Array(size);      // prev vel y
    }
    IX(i,j){ return i + (this.N+2)*j; }

    addSource(x, s, dt) {
      const N = this.N; const size=(N+2)*(N+2);
      for (let i=0;i<size;i++) x[i] += dt * s[i];
    }

    setBnd(b, x) {
      const N = this.N;
      for (let i=1;i<=N;i++) {
        x[this.IX(0, i)]     = b===1 ? -x[this.IX(1, i)]  : x[this.IX(1, i)];
        x[this.IX(N+1, i)]   = b===1 ? -x[this.IX(N, i)]  : x[this.IX(N, i)];
        x[this.IX(i, 0)]     = b===2 ? -x[this.IX(i, 1)]  : x[this.IX(i, 1)];
        x[this.IX(i, N+1)]   = b===2 ? -x[this.IX(i, N)]  : x[this.IX(i, N)];
      }
      x[this.IX(0,0)]           = 0.5 * (x[this.IX(1,0)] + x[this.IX(0,1)]);
      x[this.IX(0,N+1)]         = 0.5 * (x[this.IX(1,N+1)] + x[this.IX(0,N)]);
      x[this.IX(N+1,0)]         = 0.5 * (x[this.IX(N,0)] + x[this.IX(N+1,1)]);
      x[this.IX(N+1,N+1)]       = 0.5 * (x[this.IX(N,N+1)] + x[this.IX(N+1,N)]);
    }

    linSolve(b, x, x0, a, c) {
      const N = this.N;
      for (let k=0;k<20;k++) {
        for (let i=1;i<=N;i++) {
          for (let j=1;j<=N;j++) {
            x[this.IX(i,j)] = (x0[this.IX(i,j)] + a*( x[this.IX(i-1,j)] + x[this.IX(i+1,j)] + x[this.IX(i,j-1)] + x[this.IX(i,j+1)] )) / c;
          }
        }
        this.setBnd(b,x);
      }
    }

    diffuse(b, x, x0, diff, dt) {
      const N = this.N;
      const a = dt * diff * N * N;
      this.linSolve(b, x, x0, a, 1 + 4*a);
    }

    advect(b, d, d0, u, v, dt) {
      const N = this.N;
      const dt0 = dt*N;
      for (let i=1;i<=N;i++) {
        for (let j=1;j<=N;j++) {
          let x = i - dt0 * u[this.IX(i,j)];
          let y = j - dt0 * v[this.IX(i,j)];
          if (x<0.5) x=0.5; if (x>N+0.5) x=N+0.5;
          if (y<0.5) y=0.5; if (y>N+0.5) y=N+0.5;
          const i0 = Math.floor(x), i1 = i0 + 1;
          const j0 = Math.floor(y), j1 = j0 + 1;
          const s1 = x - i0, s0 = 1 - s1;
          const t1 = y - j0, t0 = 1 - t1;
          d[this.IX(i,j)] =
            s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) +
            s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);
        }
      }
      this.setBnd(b,d);
    }

    project(u, v, p, div) {
      const N = this.N;
      for (let i=1;i<=N;i++) {
        for (let j=1;j<=N;j++) {
          div[this.IX(i,j)] = -0.5*( u[this.IX(i+1,j)] - u[this.IX(i-1,j)] + v[this.IX(i,j+1)] - v[this.IX(i,j-1)] )/N;
          p[this.IX(i,j)] = 0;
        }
      }
      this.setBnd(0, div);
      this.setBnd(0, p);
      this.linSolve(0, p, div, 1, 4);
      for (let i=1;i<=N;i++) {
        for (let j=1;j<=N;j++) {
          u[this.IX(i,j)] -= 0.5*N*(p[this.IX(i+1,j)] - p[this.IX(i-1,j)]);
          v[this.IX(i,j)] -= 0.5*N*(p[this.IX(i,j+1)] - p[this.IX(i,j-1)]);
        }
      }
      this.setBnd(1, u);
      this.setBnd(2, v);
    }

    step() {
      const N=this.N, dt=this.dt;
      // velocity
      this.addSource(this.u, this.u0, dt);
      this.addSource(this.v, this.v0, dt);
      [this.u0, this.u] = [this.u, this.u0]; // swap
      [this.v0, this.v] = [this.v, this.v0];
      this.diffuse(1, this.u, this.u0, this.visc, dt);
      this.diffuse(2, this.v, this.v0, this.visc, dt);
      this.project(this.u, this.v, this.u0, this.v0);
      [this.u0, this.u] = [this.u, this.u0];
      [this.v0, this.v] = [this.v, this.v0];
      this.advect(1, this.u, this.u0, this.u0, this.v0, dt);
      this.advect(2, this.v, this.v0, this.u0, this.v0, dt);
      this.project(this.u, this.v, this.u0, this.v0);

      // density
      this.addSource(this.d, this.d0, dt);
      [this.d0, this.d] = [this.d, this.d0];
      this.diffuse(0, this.d, this.d0, this.diff, dt);
      [this.d0, this.d] = [this.d, this.d0];
      this.advect(0, this.d, this.d0, this.u, this.v, dt);

      // clear sources for next frame
      this.u0.fill(0); this.v0.fill(0);
      this.d0.fill(0);
    }

    clear() {
      this.s.fill(0); this.d.fill(0); this.d0.fill(0);
      this.u.fill(0); this.v.fill(0); this.u0.fill(0); this.v0.fill(0);
    }
  }

  // =============== App State ===============
  const fluidCanvas = document.getElementById('fluid');
  const fctx = fluidCanvas.getContext('2d');
  const motionCanvas = document.getElementById('motion');
  const mctx = motionCanvas.getContext('2d', { willReadFrequently: true });
  const motionDebugBox = document.getElementById('motionDebug');
  const video = document.getElementById('video');

  const statusEl = document.getElementById('status');

  const resSel = document.getElementById('res');
  const viscSl = document.getElementById('visc');
  const diffSl = document.getElementById('diff');
  const forceSl = document.getElementById('force');
  const dyeSl = document.getElementById('dye');
  const threshSl = document.getElementById('thresh');
  const blurSl = document.getElementById('blur');

  const viscVal = document.getElementById('viscVal');
  const diffVal = document.getElementById('diffVal');
  const forceVal = document.getElementById('forceVal');
  const dyeVal = document.getElementById('dyeVal');
  const threshVal = document.getElementById('threshVal');
  const blurVal = document.getElementById('blurVal');

  const resetBtn = document.getElementById('resetBaseline');
  const clearBtn = document.getElementById('clearFluid');
  const pauseBtn = document.getElementById('pause');
  const resumeBtn = document.getElementById('resume');
  const showMotion = document.getElementById('showMotion');

  let paused = false;
  let N = parseInt(resSel.value, 10);
  let fluid = new Fluid(N, 1/60, parseFloat(diffSl.value), parseFloat(viscSl.value));

  // Canvas size is the simulation grid; CSS scales to full screen
  function resizeCanvases() {
    fluidCanvas.width = N;
    fluidCanvas.height = N;
    motionCanvas.width = N;
    motionCanvas.height = N;
  }
  resizeCanvases();

  let baseImage = null;   // ImageData for baseline (motion reference)
  let prevFrame = null;   // previous current frame (optional)
  let baselineTimeout = null;

  // =============== Webcam Init ===============
  async function initWebcam() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      video.srcObject = stream;
      status('üé• Camera ready');
    } catch (e) {
      status('‚ö†Ô∏è Camera blocked');
      console.error(e);
      alert('Unable to access webcam. Please allow camera permission and use HTTPS or localhost.');
    }
  }

  // =============== Motion Processing ===============
  // Draw video frame into motionCanvas (N x N), mirrored for natural feel. Keep aspect ratio by cropping.
  function drawVideoToMotionCanvas() {
    const vw = video.videoWidth || 640, vh = video.videoHeight || 480;
    if (vw === 0 || vh === 0) return;

    mctx.save();
    mctx.scale(-1, 1); // horizontal mirror
    // Compute cover-fit crop to N x N
    const canvasW = N, canvasH = N;
    const videoAR = vw / vh;
    const canvasAR = canvasW / canvasH;
    let sx, sy, sW, sH;
    if (videoAR > canvasAR) {
      // video is wider: crop width
      sH = vh;
      sW = vh * canvasAR;
      sx = (vw - sW) * 0.5;
      sy = 0;
    } else {
      // video is taller: crop height
      sW = vw;
      sH = vw / canvasAR;
      sx = 0;
      sy = (vh - sH) * 0.5;
    }
    // draw mirrored: destination x is negative width then shifted
    mctx.drawImage(video, sx, sy, sW, sH, -canvasW, 0, canvasW, canvasH);
    mctx.restore();
  }

  // Simple box blur on a 1-channel Float32Array (in-place), radius = 0..2
  function boxBlur1C(buf, w, h, radius) {
    if (radius <= 0) return;
    const tmp = new Float32Array(buf.length);
    // horizontal
    for (let y=0;y<h;y++) {
      let acc=0, count=0;
      for (let x=0;x<w;x++) {
        const idx = x + y*w;
        acc += buf[idx]; count++;
        if (x - radius >= 0) { acc -= buf[idx - radius]; count--; }
        if (x + radius < w)  { /* window grows until full */ }
        tmp[idx] = acc / count;
      }
    }
    // vertical
    for (let x=0;x<w;x++) {
      let acc=0, count=0;
      for (let y=0;y<h;y++) {
        const idx = x + y*w;
        acc += tmp[idx]; count++;
        if (y - radius >= 0) { acc -= tmp[idx - radius*w]; count--; }
        buf[idx] = acc / count;
      }
    }
  }

  function processMotionAndInject() {
    drawVideoToMotionCanvas();
    const frame = mctx.getImageData(0,0,N,N);
    const data = frame.data;

    if (!baseImage) {
      baseImage = mctx.getImageData(0,0,N,N);
      prevFrame = frame;
      return;
    }

    const threshold = parseFloat(threshSl.value);
    const forceScale = parseFloat(forceSl.value);
    const densityScale = parseFloat(dyeSl.value);
    const blurR = parseInt(blurSl.value, 10);

    // 1) Build 1-channel motion magnitude: abs(lum(curr)-lum(base))
    const lumCurr = new Float32Array(N*N);
    const motion = new Float32Array(N*N);

    for (let j=0;j<N;j++) {
      for (let i=0;i<N;i++) {
        const k = (i + j*N) * 4;
        const r = data[k], g = data[k+1], b = data[k+2];
        const lum = 0.299*r + 0.587*g + 0.114*b;
        lumCurr[i + j*N] = lum;

        const br = baseImage.data[k], bg = baseImage.data[k+1], bb = baseImage.data[k+2];
        const lumBase = 0.299*br + 0.587*bg + 0.114*bb;
        motion[i + j*N] = Math.abs(lum - lumBase);
      }
    }

    // Optional blur to stabilize noise
    boxBlur1C(motion, N, N, blurR);

    // 2) Simple spatial gradient of current luminance as a plausible push direction
    // (This approximates local edges; not true optical flow but feels dynamic.)
    // vx = d/dx, vy = d/dy of luminance
    for (let j=1;j<N-1;j++) {
      for (let i=1;i<N-1;i++) {
        const idx = i + j*N;
        const mag = motion[idx];
        if (mag < threshold) continue;

        const gx = lumCurr[idx+1] - lumCurr[idx-1];
        const gy = lumCurr[idx+N] - lumCurr[idx-N];

        // inject velocity and density
        const f = (mag - threshold) / 255; // normalize roughly
        const pushX = gx * f / 255 * forceScale;
        const pushY = gy * f / 255 * forceScale;

        const IX = fluid.IX(i,j);
        fluid.u0[IX] += pushX;
        fluid.v0[IX] += pushY;

        fluid.d0[IX] += f * densityScale;
      }
    }

    prevFrame = frame;

    // Draw motion debug if toggled
    if (motionDebugBox.style.display !== 'none') {
      const dbg = mctx.createImageData(N,N);
      for (let j=0;j<N;j++) {
        for (let i=0;i<N;i++) {
          const idx = i + j*N;
          const v = clamp(motion[idx], 0, 255);
          const p = idx*4;
          dbg.data[p] = v;      // red
          dbg.data[p+1] = 0;    // green
          dbg.data[p+2] = 255 - v; // blue
          dbg.data[p+3] = 255;
        }
      }
      mctx.putImageData(dbg, 0, 0);
    }
  }

  // =============== Rendering ===============
  function renderFluid() {
    // paint density field to canvas
    const img = fctx.createImageData(N, N);
    for (let j=1;j<=N;j++) {
      for (let i=1;i<=N;i++) {
        const IX = fluid.IX(i,j);
        const d = fluid.d[IX];
        const [r,g,b] = densityToRGB(d);
        const p = ((i-1) + (j-1)*N) * 4;
        img.data[p] = r|0;
        img.data[p+1] = g|0;
        img.data[p+2] = b|0;
        img.data[p+3] = clamp(d*120 + 60, 0, 255) | 0; // alpha scales with density
      }
    }
    fctx.putImageData(img, 0, 0);
  }

  // =============== Loop ===============
  let lastT = performance.now();
  function tick(t) {
    const dt = Math.min((t - lastT) / 1000, 0.05); // cap dt
    lastT = t;

    fluid.dt = dt;
    fluid.visc = parseFloat(viscSl.value);
    fluid.diff = parseFloat(diffSl.value);

    if (!paused) {
      processMotionAndInject();
      fluid.step();
      renderFluid();
    }
    requestAnimationFrame(tick);
  }

  // =============== UI wiring ===============
  function status(msg) { statusEl.textContent = msg; }

  // Update value labels
  function bindSlider(sl, label, formatter=(v)=>v) {
    const update = () => { label.textContent = formatter(parseFloat(sl.value)); };
    sl.addEventListener('input', update);
    update();
  }
  bindSlider(viscSl, viscVal, v => v.toFixed(4));
  bindSlider(diffSl, diffVal, v => v.toFixed(4));
  bindSlider(forceSl, forceVal, v => v.toFixed(0));
  bindSlider(dyeSl, dyeVal, v => v.toFixed(2));
  bindSlider(threshSl, threshVal, v => v.toFixed(0));
  bindSlider(blurSl, blurVal, v => v.toFixed(0));

  resSel.addEventListener('change', () => {
    N = parseInt(resSel.value, 10);
    const diff = parseFloat(diffSl.value);
    const visc = parseFloat(viscSl.value);
    fluid = new Fluid(N, fluid.dt, diff, visc);
    resizeCanvases();
    baseImage = null; prevFrame = null; // force re-baseline at new size
    status('‚Üª Grid rebuilt');
  });

  clearBtn.addEventListener('click', () => {
    fluid.clear();
    status('üßπ Cleared');
  });

  pauseBtn.addEventListener('click', () => {
    paused = true;
    pauseBtn.disabled = true; resumeBtn.disabled = false;
    status('‚è∏ Paused');
  });
  resumeBtn.addEventListener('click', () => {
    paused = false;
    pauseBtn.disabled = false; resumeBtn.disabled = true;
    status('‚ñ∂Ô∏è Running');
  });

  showMotion.addEventListener('change', (e) => {
    motionDebugBox.style.display = e.target.checked ? 'block' : 'none';
  });

  resetBtn.addEventListener('click', () => {
    if (baselineTimeout) { clearTimeout(baselineTimeout); baselineTimeout = null; }
    let countdown = 3;
    status(`‚è≥ Reset in ${countdown}s`);
    const id = setInterval(() => {
      countdown--;
      status(`‚è≥ Reset in ${countdown}s`);
      if (countdown <= 0) {
        clearInterval(id);
      }
    }, 1000);
    baselineTimeout = setTimeout(() => {
      // capture fresh baseline from current video frame size N x N
      drawVideoToMotionCanvas();
      baseImage = mctx.getImageData(0,0,N,N);
      status('‚úÖ Baseline updated');
      baselineTimeout = null;
    }, 3000);
  });

  // Optional: mouse drag to stir
  let dragging = false, lastX=0, lastY=0;
  fluidCanvas.addEventListener('pointerdown', (e) => { dragging = true; lastX = e.offsetX; lastY = e.offsetY; fluidCanvas.setPointerCapture(e.pointerId); });
  fluidCanvas.addEventListener('pointerup', (e) => { dragging = false; fluidCanvas.releasePointerCapture(e.pointerId); });
  fluidCanvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const rect = fluidCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width * N + 1;
    const y = (e.clientY - rect.top) / rect.height * N + 1;
    const ix = clamp(Math.floor(x), 1, N);
    const iy = clamp(Math.floor(y), 1, N);
    const IX = fluid.IX(ix, iy);
    const dx = (e.offsetX - lastX) * 0.15;
    const dy = (e.offsetY - lastY) * 0.15;
    fluid.u0[IX] += dx;
    fluid.v0[IX] += dy;
    fluid.d0[IX] += 1.2;
    lastX = e.offsetX; lastY = e.offsetY;
  });

  // Kick things off
  initWebcam().then(() => {
    requestAnimationFrame(tick);
  });

})();
</script>
</body>
</html>
